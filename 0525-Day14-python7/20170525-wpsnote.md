## 매직 메서드

#### `__new__()`

- 클래스를 실행할 때 실행되는 매직 메서드
- a = Class(). #__new__ 실행

<br>

#### `__str__()`

- 객체를 이해하기 쉽게 표현할 수 있는 문자열 
- str(), format(), print()에 의해 호출된다.
- type of node_p : print(type(node_p))
		- <class '__main__.Node'>
- node_p itself print(node_p)
 		- <__mai n__.Node object at 0x105944a20>
 
<br>

#### `__repr__()`

- 객체를 나타내는 공식적인 문자열

> 쉽게 말하면 __str__ 은 사용자가 보기 쉬운 형태로 보여줄 때 사용하는 것이고, __repr__ 은 시스템(python interpreter)이 해당 객체를 인식할 수 있는 공식적인 문자열로 나타내 줄 때 사용하는 것이다.
출처: http://pinocc.tistory.com/168 [땅뚱 창고]


<br>


### 속성관리 특수 메서드


<br>

## 가상환경 생성 

- `pyenv virtualenv 3.5.3 <가상환경 이름>` : 가상환경을 새로 생성(python 3.5.3 버전으로 pyenv virtualenv 패키지 실행)
- `pyenv local crawling` : crawling을 로컬위치에 지정
- pycharm에서 해당 폴더로 오픈한 후 가상환경 찾아서 설정

<br>

### 동기와 비동기

>비동기 (Asynchronous: 동시에 일어나지 않는, 非同期: 같은 시기가 아닌)
비동기란 말 그대로 동시에 일어나지 않는다는 의미입니다. 무엇이 같이 일어나지 않는다는 말일까요? 바로 요청과 그 결과가 동시에 일어나지 않을 거라는 약속입니다. 즉, 요청한 그 자리에서 바로 결과가 주어지는 것이 아니라, 이따가 줄게라고 약속하는 것이죠.
동기 (synchronous: 동시에 일어나는, 同期: 같은 시기)
동기란 동시에 일어난다는 말입니다. 무엇이 동시에 일어날까요? 요청과 그 결과가 동시에 일어난다는 약속입니다. 바로 요청을 하면 그 요청한 자리에서 바로 결과가 주어져야 한다는 말이죠. 시간이 얼마가 걸리든지 상관없습니다, 동기방식으로 하겠다는 것은 시간이 얼마가 걸리든 요청한 그 자리에서 결과를 주겠다는 약속이기 때문이죠. 즉, 요청과 결과가 한자리에서 동시에 일어난다는 말입니다.
동기와 비동기를 구분하는 이유
동기와 비동기를 굳이 구분하는 이유는 상황에 따라서 장단점이 있기 때문입니다. 동기방식은 매우 설계가 간단하고 직관적이지만, 결과가 주어질 때까지 아무것도 못하고 대기해야 하는 단점이 있습니다. 비동기방식은 좀더 복잡하지만 결과가 주어지는 시간이 길어져도 그 시간 동안 다른 작업을 할 수 있으므로 좀더 효율적으로 자원을 사용할 수 있는 장점이 있습니다.
블로킹(Blocking)
블로킹은 말 그대로 작업이 중단된다는 의미입니다. 네트워크 통신에서 요청이 발생하고 완료될 때까지 모든 일을 중단한 상태로 대기해야 하는 것을 블로킹 방식이라 합니다.
소켓통신을 해보신 분들은 알겠지만, 블로킹 방식의 소켓통신은 결과가 올 때까지 다른 작업을 중단하고 하염없이 기다리게 됩니다.
논블로킹(Non-blocking)
논블러킹은 말 그대로 중단되지 않는다는 말입니다. 통신이 완료 될 때까지 중단되는 블로킹의 반대 개념입니다.
논블로킹 방식은 아무래도 통신이 완료될 때까지 기다리지 않고 다른 작업을 수행할 수 있으므로 경우에 따라 효율이나 반응속도가 더 뛰어납니다. 반면에 좀더 설계가 복잡해진다는 단점이 있습니다.
출처: http://nsinc.tistory.com/108 [NakedStrength Inc.]

<br>

### HTTP

- 1번의 요청은 반드시 1번의 응답으로 되돌아온다.
- 세자리 수로 된 응답코드


<br>

## REquests

~~~
# 가져올 url
# http://comic.naver.com/webtoon/list.nhn?titleId=679519&weekday=thu

# url의 범위 
# http://comic.naver.com/webtoon/list.nhn

# parameter의 범위
# 'titleId': 679519, 'weekday': 'thu'
~~~

<br>

#### r.text 

- 모든 데이터는 전송받기 전에 이진데이터 형식으로 저장한다. 
- 디코딩할 때 `r.text`라는 명령어를 사용한다. 

- `r.content`로 미리 인코딩된 내용을 확인할 수 있다.
- 내용을 가져오고 싶으면 `r.encoding`을 하고, `r.text`를 사용하면 된다. 


find_all() - 모든 속성을 가져오므로 다른 타입의 데이터가 섞여 있으면 반환이 되지 않을 수 있다. 
find() 


숙제 

1. 전체 에피소드 가져오기
2. 에피소드 번호를 입력하면(no) 내부의 웹툰 이미지 주소를 가져오기(여러 장의 이미지로 분할되어 있음)
- 전체이미지는 계속 가져올 경우 차단될 수 있음.
3. 썸네일이미지 또는 내부 웹툰이미지를 저장
4. 모든 것을 통합해서 웹툰을 각 화별 폴더를 생성해 저장하기
5. 저장한 파일을 접근할 수 있는 html생성



















